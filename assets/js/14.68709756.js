(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{367:function(e,t,a){"use strict";a.r(t);var s=a(17),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"using-magpurify2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-magpurify2"}},[e._v("#")]),e._v(" Using MAGpurify2")]),e._v(" "),a("h2",{attrs:{id:"generating-bins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generating-bins"}},[e._v("#")]),e._v(" Generating bins")]),e._v(" "),a("p",[a("em",[e._v("Recommend binners and DAS Tool.")])]),e._v(" "),a("h2",{attrs:{id:"quick-start"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quick-start"}},[e._v("#")]),e._v(" Quick start")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("magpurify2 composition test_data/genomes/* output\nmagpurify2 coverage test_data/genomes/* output --bam_files test_data/bam_files/*\nmagpurify2 taxonomy test_data/genomes/* output magpurify2DB\nmagpurify2 filter test_data/genomes/* output filtered_genomes\n")])])]),a("h2",{attrs:{id:"the-composition-module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-composition-module"}},[e._v("#")]),e._v(" The "),a("code",[e._v("composition")]),e._v(" module")]),e._v(" "),a("p",[a("code",[e._v("magpurify2 composition")]),e._v(" is the command used to identify putative contaminants using tetranucleotide frequencies.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("usage: magpurify2 composition [-h] [-s STRICTNESS] [-t THREADS] [--quiet] genomes [genomes ...] output_directory\n\npositional arguments:\n  genomes               Input genomes in the FASTA format.\n  output_directory      Directory to write the output files to.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s STRICTNESS, --strictness STRICTNESS\n                        Strictness of the contaminant detection algorithm. Must be a number between 0 (less strict) and 1 (more strict). (default: 0.5)\n  -t THREADS, --threads THREADS\n                        Number of threads to use. All by default. (default: 4)\n  --quiet               Suppress the logger output (default: False)\n")])])]),a("h2",{attrs:{id:"the-coverage-module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-coverage-module"}},[e._v("#")]),e._v(" The "),a("code",[e._v("coverage")]),e._v(" module")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("How to generate the BAM files")]),e._v(" "),a("p",[e._v("BAM files store read alignment information to the target metagenome (or MAG) and used by MAGpurify2 to estimate the coverage of each contig. To generate the BAM inputs to MAGpurify2 you should first map your reads to the complete metagenome using a proper tool (such as "),a("a",{attrs:{href:"https://github.com/BenLangmead/bowtie2",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bowtie 2"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/lh3/minimap2",target:"_blank",rel:"noopener noreferrer"}},[e._v("minimap2"),a("OutboundLink")],1),e._v(" or "),a("a",{attrs:{href:"https://github.com/bwa-mem2/bwa-mem2",target:"_blank",rel:"noopener noreferrer"}},[e._v("BWA-MEM2"),a("OutboundLink")],1),e._v(") and then convert and sort the output using "),a("a",{attrs:{href:"https://github.com/samtools/samtools",target:"_blank",rel:"noopener noreferrer"}},[e._v("samtools"),a("OutboundLink")],1),e._v(". For example:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Create a Bowtie 2 index for your metagenome inside the 'bt2' directory:")]),e._v("\n$ "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" bt2\n$ bowtie2-build --threads "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v(" metagenome.fna bt2/metagenome\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Map the reads, sort the output and save it to 'sample1.bam':")]),e._v("\n$ bowtie2 --threads "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v(" -x bt2/metagenome "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n  -1 sample1_R1.fastq.gz -2 sample1_R2.fastq.gz "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" samtools "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sort")]),e._v(" -@ "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v(" -o sample1.bam -\n")])])]),a("p",[e._v("We recommend mapping the reads to the metagenome (superset) and not directly to the MAGs retrieved from it (subsets). There are two main reasons for that:")]),e._v(" "),a("ul",[a("li",[e._v("When you map the reads to the MAG there's a chance that reads that were originated from the sequencing of a closely related genome will be erroneously aligned to the MAG (cross-mapping), introducing bias to the coverage estimation.")]),e._v(" "),a("li",[e._v("Metagenome-wide mappings can be used to estimate the coverage of all the contigs in the metagenome, thus allowing MAGpurify2 to process multiple MAGs in a single execution.")])]),e._v(" "),a("p",[e._v("If the target MAGs are derived from multiple source metagenomes you need input BAM files containing read mappings to each one of them.")])]),e._v(" "),a("p",[e._v("If you don't have access to the raw sequencing data or to previously generated BAM files you can input coverage data stored in a tab-separated values (TSV) file. To do so, you should use the "),a("code",[e._v("--coverage_file")]),e._v(" argument:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("coverage genomes/* output --coverage_file contig_coverages.tsv --threads 4\n")])])]),a("p",[e._v("The first column of the coverage file must store the contigs names. The remaining columns should contain the coverage of each contig across multiple samples, as shown in the example below:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contig_1     15.744    12.605    25.148    3.728    0.000\ncontig_2     34.466    48.019    18.222    3.707    4.195\ncontig_3      0.000    22.356    21.944    4.479    4.463\ncontig_4     14.201     9.993     0.000    0.925    4.608\ncontig_5     17.179    12.280    56.643    3.586    4.226\ncontig_6      5.239     8.430    5.2070    3.988    0.000\ncontig_7     17.737    16.005    29.692    4.039    4.190\ncontig_8      0.000    15.866    13.663    0.877    2.269\ncontig_9     19.129    15.145    21.249    0.000    2.342\ncontig_10    11.074     9.574    19.673    0.934    4.732\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);